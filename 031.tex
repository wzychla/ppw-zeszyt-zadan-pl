\section{Biblioteka standardowa .NET (15)}

    Biblioteka standardowa platformy .NET bardzo szybko się rozwija. Współcześnie obejmuje właściwie większość możliwych aspektów technologicznych, przez różne
	podsystemy interfejsu użytkownika, podsystemy graficzne, usługi sieciowe, systemy plików, podsystemy kryptograficzne, usługi kolejkowe i katalogowe, komunikację z systemami
	relacyjnych i nierelacyjnych baz danych oraz programowanie serwerów aplikacyjnych. Jest to ogromny i fascynujący świat, który ma to do siebie, że obojętnie jak dobrze się go zna,
	zawsze można znaleźć tu coś nowego i zajmującego.

	Z uwagi na ograniczone ramy czasowe, przegląd biblioteki standardowej ma tu charakter wybiórczy. 
	
	Ponieważ w przyszłych wersjach systemu operacyjnego Windows interfejs BCL ma szansę
	  stać się natywnym interfejsem programowania Windows, warto szczegółowo zapoznać się z jego możliwościami.
      
\subsection{Własna kompletna klasa usługowa (1)}
      Napisać klasę do obsługi liczb zespolonych. Dodać odpowiednie konstruktory, przeciążyć odpowiednie operatory.
\label{liczby_zespolone}
      
      Rozszerzyć tę klasę o własne formatowane. Ściślej, zaimplementować interfejs
      {\tt IFormat\-table} i obsługiwać dwa rodzaje formatowania:
      \begin{itemize}
      \item domyślne (brak formatowania lub {\tt d}) powinno dawać wynik $a+bi$ 
      \item wektorowe (format {\tt w}) powinno dawać wynik $[a,b]$.
      \end{itemize}
      
      Przykładowy kawałek kodu:
      \begin{verbatim}
      Complex z = new Complex( 4, 3 );
      Console.WriteLine( String.Format( "{0}", z ) );
      Console.WriteLine( String.Format( "{0:d}", z ) );
      Console.WriteLine( String.Format( "{0:w}", z ) );
      \end{verbatim}

      powinien dać wynik

      \begin{verbatim}
      4+3i
      4+3i
      [4,3]
      \end{verbatim}

      [{\bf 1p}]  
                
\subsection{Własna kolekcja danych (1)}
      
      Zaimplementować niegeneryczną kolekcję {\tt Set} działającą jak zbiór, odrzucający duplikaty elementów.
\label{wlasne_kolekcje}	  
      
      {\em Wskazówka: są trzy możliwości - albo dziedziczenie jakiejś kolekcji bibliotecznej, albo zaimplementowanie własnej kolekcji, która wewnętrznie będzie wykorzystywała
      jakąś kolekcję biblioteczną, wreszcie zaimplementowanie własnej kolekcji nie dziedziczącej z żadnej kolekcji bibliotecznej ani nie wykorzystującej wewnętrznie żadnej
      kolekcji bibliotecznej. Ta ostatnia możliwość ma niewielki sens - należy uczyć się korzystania z biblioteki standardowej i wykorzystywać jej komponenty we własnym kodzie,
      a nie wyważać otwarte drzwi implementując już istniejące mechanizmy samemu.}

      [{\bf 1p}]  

\subsection{Składanie strumieni (1)}

      Napisać program, który zawartość wskazanego pliku tekstowego zapisze do {\bf zaszyfrowanego} algorytmem AES {\bf skompresowanego} 
\label{skladanie_strumieni}	  
	  strumienia GZip.
      
      Napisać kolejny program, który odszyfruje wskazany skompresowany strumień GZip.
            
      [{\bf 1p}]

\subsection{Golibroda w .NET (2)}

      Napisać konsolowy program, który rozwiązuje klasyczny problem golibrody lub problem "palaczy tytoniu" 
\label{golibroda_net}	  
      za pomocą którejkolwiek z metod synchronizacji wątków udostępnianej przez .NET BCL.  

      [{\bf 2p}] 
      
\subsection{Protokoły sieciowe (1)}

    Zademonstrować działanie klas {\tt FtpWebRequest}, {\tt HttpWebRequest}, 
	{\tt WebClient}, {\tt HttpClient}, {\tt HttpListener},
\label{protokoly_sieciowe}	
    {\tt TcpListener}, {\tt TcpClient}, {\tt SmtpClient}.
	
	Zwrócić uwagę na te funkcje z interfejsów powyższych klas, których metody pobierania danych są zaimplementowane jako asynchroniczne (zwracają {\tt Task<T>}).

    [{\bf 1p}]

\subsection{Serializacja i przesyłanie obiektów (2)}

    Wybrać jeden z omawianych sposobów serializacji (binarne, XML, SOAP) i przygotować dwa moduły: klienta i serwera.
	
	Klient serializuje wskazany obiekt z danymi (jakaś współdzielona prosta klasa) i przesyła go do serwera. Serwer deserializuje obiekt i zapamiętuje go w pliku.
	
	{\em Wskazówka}. Do implementacji komunikacji klient-serwer można użyć klas 
    {\tt TcpClient} i {\tt TcpListener}) .
    
    [{\bf 2p}]

\subsection{Komunikacja międzyprocesowa - MSMQ (2)}

    Korzystając z MSMQ ({\tt System.Messaging}) utworzyć
\label{msmq}	
    dwukomponentowy system, w którym jeden z komponentów będzie
    co pewien czas tworzył dużą liczbę komunikatów, a drugi komponent
    będzie regularnie opróżniał kolejkę komunikatów, wykonując dla
    każdego z nich jakąś kilkusekundową akcję.
    
    [{\bf 2p}]

\subsection{Globalizacja (1)}

    Napisać program, który korzystając z informacji z odpowiedniej instancji obiektu {\tt CultureInfo} 
\label{globaliazcja}	
    wypisze pełne i skrótowe nazwy miesięcy i dni tygodnia oraz
    bieżącą datę w językach: 
    angielskim, niemieckim, francuskim, rosyjskim, arabskim, czeskim i polskim.
    
    [{\bf 1p}]

\subsection{Usługa systemowa (1)}

    Napisać usługę systemową ({\em System Service}), która będzie co minutę zapisywać listę
\label{system_service}	
    uruchomionych aplikacji do pliku tekstowego. 
    
    {\em Uwaga! Po skompilowaniu usługa musi zostać zarejestrowana w systemie
    za pomocą programu {\tt installutil.exe}. Zarządzanie usługami odbywa się z poziomu
    panelu {\bf Zarządzanie komputerem}, sekcja {\bf Usługi i aplikacje}.}
    
    [{\bf 1p}]

\subsection{Zewnętrzny plik w zasobach aplikacji (1)}

    Umieścić dowolny plik w zasobach aplikacji (w projekcie plik powinien mieć właściwość {\em Embedded Resource}). Następnie napisać klasę, która po
\label{plik_w_zasobach}	
	podaniu nazwy zasobu
    umożliwi wydobycie pliku z zasobów zestawu.
	
	Osadzanie plików (tekstowych, binarnych) w zasobach aplikacji przydaje się wtedy kiedy aplikacja jest dystrybuowana do środowiska klienckiego. Zamiast
	plików wykonywalnych i dodatkowych plików zasobów, klient dostaje pliki wykonywalne w zasobach których zaszyte są pliki z danymi.
        
    [{\bf 1p}]

\subsection{Dynamiczne tworzenie kodu (2)}

    Napisać program, który w czasie działania powoła do życia instancję kompilatora C\# i użyje go do skompilowania fragmentu kodu
	funkcji, wprowadzonej przez użytkownika do konsoli. Następnie skompilowany fragment zostanie włączony do aktualnie wykonywanego programu i wykonany.
	
	{\em Wskazówka. Obiekt kompilatora to klasa {\tt Microsoft.CSharp.CSharpCodeProvider}}.

    [{\bf 2p}]
