\section{Język C\# 1.0 (6)}
  
\subsection{Prosty algorytm (1)}

      Napisać program, który wyznacza zbiór wszystkich liczb natualnych 1 a 100000, które są podzielne zarówno przez każdą ze swoich cyfr z
\label{prosty_algorytm}	  
	  osobna jak i przez sumę swoich cyfr.

      [{\bf 1p}]
 
\subsection{Indeksery (1)}

  Zaimplementować klasę siatki dwuwymiarowej, {\tt Grid}, z dwoma indekserami:
\label{indeksery}  
  
	\begin{itemize}
	\item jednowymiarowym, zwracającym listę elementów zadanego wiersza tablicy, tak aby klient klasy mógł napiasć:

	      \begin{verbatim}
  ...
  Grid grid = new Grid( 4, 4 );
  int[] rowdata = grid[1]; // akcesor "get"
	      \end{verbatim}

	\item dwuwymiarowym, zwracającym określony element tablicy, tak aby klient klasy mógł napisać:
      
	      \begin{verbatim}
  ...
  Grid grid = new Grid( 4, 4 );
		  
  elem[2, 2] = 5;        // akcesor "set"
  int elem = grid[1, 4]; // akcesor "get"
	      \end{verbatim}
	      
	\end{itemize}
      
      Oba indeksery powinny przyjmować jako parametry liczby całkowite. Konstruktor klasy powinien przyjmować
	  jako parametry liczbę wierszy i liczbę kolumn siatki.
      
      [{\bf 1p}]

\subsection{Refleksja - składowe prywatne (1)}

      Napisać program, który zademonstruje możliwość dostępu z zewnątrz
\label{refleksja}	  
      do prywatnych składowych klasy.
      
      Kod programu powinien składać się z przykładowej klasy z co najmniej
      jedną prywatną metodą i właściwością. Kod kliencki powinien uzyskać dostęp
      do składowych prywatnych za pomocą refleksji.
      
      Należy ponadto porównać szybkość dostępu do składowej
      publicznej w zwykły sposób i za pomocą refleksji.
      
      {\em Wskazówka: mierzenie czasu działania bloku kodu najprościej wykonać następująco:
      
      \begin{verbatim}
DateTime Start = DateTime.Now;
/* tu blok kodu */
DateTime End = DateTime.Now;

TimeSpan Czas = Start-End;
Console.WriteLine( Czas );
      \end{verbatim}
      
      Należy jedynie pamiętać o {\bf powtórzeniu} bloku kodu w pętli tak długo, aż pomiar czasu będzie miał jakikolwiek sens - w przypadku kodu wykonywanego
      kilka/kilkanaście milisekund powyższa metoda zastosowana do jednokrotnie wykonanego bloku kodu zwróci po prostu 0 jako czas wykonania. Przykład:

      \begin{verbatim}
int LiczbaProb = 1000;      
DateTime Start = DateTime.Now;

for ( int proba=0; proba<LiczbaProb; proba++ )
{
  /* tu blok kodu */
}
DateTime End = DateTime.Now;

TimeSpan Czas = Start-End;
Console.WriteLine( Czas );
      \end{verbatim}}

Należy również pamiętać o odrzuceniu wyników kilku pierwszych pomiarów - wyniki mogą być zaburzone przez rozruch silnika JIT przyotowującego aplikację do wykonania w systemie operacyjnym.	  
	  
      [{\bf 1p}]

\subsection{Atrybuty (1)}

	Napisać funkcję, która jako parametr przyjmuje dowolny obiekt i wyszukuje wszystkie jego publiczne, niestatyczne metody zwracające
\label{atrybuty}	
    wartość typu {\bf int} i mające pustą listę parametrów.	
	
	Następnie sprośród tych metod, funkcja wywoła i wypisze na konsoli wynik wywołania wszystkich tych funkcji, które są oznakowane
	atrybutem {\bf [Oznakowane]}.
	
	Przykładowo, w poniższym fragmencie kodu na konsoli powinna pojawić się tylko wartość z funkcji {\bf Bar}.
	
\begin{verbatim}
public class Foo
{
  [Oznakowane]
  public int Bar()
  {
     return 1;
  }
  
  public int Qux()
  {
     return 2;
  }
  
}
\end{verbatim}	

      [{\bf 1p}]

\subsection{Dokumentowanie kodu (1)}

      Zdokumentować (przez umieszczenie odpowiednich komentarzy w kodzie)
\label{dokumentowanie}	  
      jeden dowolny program z bieżącej sekcji. 

      Wygenerować dokumentację w postaci pliku XML podczas kompilacji. Użyć
      narzędzia SandCastle Help File Builder ({\tt http://shfb.codeplex.com/}) do zbudowania
      pomocy stylach HTML Help i MSDN-online.

      [{\bf 1p}]

\subsection{Dekompilacja kodu (1)}

      Napisać w C\# dowolny program demonstrujący użycie klas (metod, pól, propercji, indekserów, delegacji i zdarzeń) oraz podstawowych
\label{dekompilacja}	  
      konstrukcji składniowych (pętle, instrukcje warunkowe, {\tt switch})
      i zdekompilować go do wybranego przez siebie języka (VB.NET lub CIL)
      za pomocą narzędzia {\bf IlSpy} ({\tt http://ilspy.net/}).
      
      Otrzymany kod skompilować odpowiednim kompilatorem, aby otrzymać plik wynikowy.
      Plik ten następnie zdekompilować na powrót do języka C\#.
      
      Porównać otrzymane w ten sposób pliki z kodem źródłowym.
      Jak objawiają się i z czego wynikają różnice?

      [{\bf 1p}]
