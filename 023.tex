\section{Rozszerzenia języka C\# 2.0 (6)}

\subsection{Kontenery generyczne (1)}

  Porównać wydajność (dodawanie elementów, przeglądanie, usuwanie) par kontenerów: {\tt ArrayList} - {\tt List<T>} 
\label{kontener_generyczny}  
  oraz {\tt Hashtable} - {\tt Dictionary<T,K>}.

  [{\bf 1p}]

\subsection{Drzewo binarne (3)}

  Napisać klasę {\tt BinaryTreeNode<T>}, która będzie modelem dla węzła
\label{drzewo_binarne}  
  drzewa binarnego. Węzeł powinien przechowywać informację o danej typu {\tt T} oraz swoim lewym i prawym synu.
   
  Klasa powinna zawierać dwa enumeratory, dla przechodzenia drzewa w głąb i wszerz, 
  zaprogramowane w dwu wariantach: z wykorzystaniem słowa kluczowego {\tt yield} i bez (czyli łącznie cztery implementacje enumeratorów)
  
  {\em Wskazówka: choć implementacja bez {\tt yield} może wydawać się trudna, w rzeczywistości jest również stosunkowo prosta. Należy 
  wykorzystać pomocnicze struktury danych, przechowującą informację o odwiedzanych węzłach. Każdy {\tt MoveNext} ogląda bieżący węzeł, a jego
  podwęzły, lewy i prawy, umieszcza w pomocniczej strukturze danych. Każdy {\tt Current} usuwa bieżący węzeł z pomocniczej struktury 
  i zwraca jako wynik. Strukturę danych dobiera się w zależności od tego czy chce się implementować przechodzenie wszerz czy wgłąb
  (jakie struktury danych należy wybrać dla każdego z tych wariantów?)}
  
  [{\bf 3p}]

\subsection{Anonimowe delegacje {\tt Predicate}, {\tt Action}, {\tt Comparison}, {\tt Converter} (1)}

  Zademonstrować w działaniu metody {\tt ConvertAll}, {\tt FindAll},  {\tt ForEach},  {\tt RemoveAll} i {\tt Sort} klasy
\label{anonimowe_delegacje}  
  {\tt List<T>} używając anonimowych delegacji o odpowiednich sygnaturach.

  [{\bf 1p}]

\subsection{Algorytmy biblioteczne (1)}

  W klasie {\tt ListHelper} 
\label{algorytmy_biblioteczne}  
  zaprogramować statyczne metody {\tt ConvertAll}, {\tt FindAll},  {\tt ForEach},  {\tt RemoveAll} i {\tt Sort} 
  o semantyce zgodnej z odpowiednimi funkcjami z klasy {\tt List<T>} i sygnaturach rozszerzonych względem odpowiedników
  o instancję obiektu {\tt List<T>} na którym mają operować. 
        
\begin{verbatim}
public class ListHelper
{
  public static List<TOutput> ConvertAll<T, TOutput>( 
    List<T> list, 
    Converter<T, TOutput> converter );
  public static List<T> FindAll<T>( 
    List<T> list, 
    Predicate<T> match );
  public static void ForEach<T>( List<T>, Action<T> action );
  public static int RemoveAll<T>( 
    List<T> list, 
    Predicate<T> match );
  public static void Sort<T>( 
    List<T> list, 
    Comparision<T> comparison );    
}
\end{verbatim}

  [{\bf 1p}]

