\section{Rozszerzenia jêzyka C\# 2.0 (6)}

\subsection{Kontenery generyczne (1)}

  Porównaæ wydajnoœæ (dodawanie elementów, przegl¹danie, usuwanie) par kontenerów: {\tt ArrayList} - {\tt List<T>} 
\label{kontener_generyczny}  
  oraz {\tt Hashtable} - {\tt Dictionary<T,K>}.

  [{\bf 1p}]

\subsection{Drzewo binarne (3)}

  Napisaæ klasê {\tt BinaryTreeNode<T>}, która bêdzie modelem dla wêz³a
\label{drzewo_binarne}  
  drzewa binarnego. Wêze³ powinien przechowywaæ informacjê o danej typu {\tt T} oraz swoim lewym i prawym synu.
   
  Klasa powinna zawieraæ dwa enumeratory, dla przechodzenia drzewa w g³¹b i wszerz, 
  zaprogramowane w dwu wariantach: z wykorzystaniem s³owa kluczowego {\tt yield} i bez (czyli ³¹cznie cztery implementacje enumeratorów)
  
  {\em Wskazówka: choæ implementacja bez {\tt yield} mo¿e wydawaæ siê trudna, w rzeczywistoœci jest równie¿ stosunkowo prosta. Nale¿y 
  wykorzystaæ pomocnicze struktury danych, przechowuj¹c¹ informacjê o odwiedzanych wêz³ach. Ka¿dy {\tt MoveNext} ogl¹da bie¿¹cy wêze³, a jego
  podwêz³y, lewy i prawy, umieszcza w pomocniczej strukturze danych. Ka¿dy {\tt Current} usuwa bie¿¹cy wêze³ z pomocniczej struktury 
  i zwraca jako wynik. Strukturê danych dobiera siê w zale¿noœci od tego czy chce siê implementowaæ przechodzenie wszerz czy wg³¹b
  (jakie struktury danych nale¿y wybraæ dla ka¿dego z tych wariantów?)}
  
  [{\bf 3p}]

\subsection{Anonimowe delegacje {\tt Predicate}, {\tt Action}, {\tt Comparison}, {\tt Converter} (1)}

  Zademonstrowaæ w dzia³aniu metody {\tt ConvertAll}, {\tt FindAll},  {\tt ForEach},  {\tt RemoveAll} i {\tt Sort} klasy
\label{anonimowe_delegacje}  
  {\tt List<T>} u¿ywaj¹c anonimowych delegacji o odpowiednich sygnaturach.

  [{\bf 1p}]

\subsection{Algorytmy biblioteczne (1)}

  W klasie {\tt ListHelper} 
\label{algorytmy_biblioteczne}  
  zaprogramowaæ statyczne metody {\tt ConvertAll}, {\tt FindAll},  {\tt ForEach},  {\tt RemoveAll} i {\tt Sort} 
  o semantyce zgodnej z odpowiednimi funkcjami z klasy {\tt List<T>} i sygnaturach rozszerzonych wzglêdem odpowiedników
  o instancjê obiektu {\tt List<T>} na którym maj¹ operowaæ. 
        
\begin{verbatim}
public class ListHelper
{
  public static List<TOutput> ConvertAll<T, TOutput>( 
    List<T> list, 
    Converter<T, TOutput> converter );
  public static List<T> FindAll<T>( 
    List<T> list, 
    Predicate<T> match );
  public static void ForEach<T>( List<T>, Action<T> action );
  public static int RemoveAll<T>( 
    List<T> list, 
    Predicate<T> match );
  public static void Sort<T>( 
    List<T> list, 
    Comparision<T> comparison );    
}
\end{verbatim}

  [{\bf 1p}]

